{
  "hash": "376d9ffc9037c7ff52d6ee3ed1e1e911",
  "result": {
    "markdown": "---\ntitle: \"Study on Marine Aquaculture with Geospatial Ocean Data\"\ndescription: |\n  \"Determining which Exclusive Economic Zones (EEZ) on the West Coast of the US are best suited to developing marine aquaculture for several species of marine organims\"\nauthor:\n  - name: Jared Petry \n    url: https://jaredbpetry.github.io\n    affiliation: Master of Environmental Data Science Program at UCSB\ndate: 2022-12-01\nbibliography: references.bib\ncatagories: [MEDS, R, geospatial, aquaculture]\n#citation: \n  #url:\n  #photo:\nimage: images/cover_pic.png\ndraft: false\nformat: \n  html: \n    code-fold: true\n    code-summary: \"Show Code\"\n    toc: true\n    toc-depth: 6 \n    toc-title: Contents\ncode-overflow: wrap\ncode-block-bg: true\ncode-block-border-left: \"#6B5A75\"\neditor: visual\n---\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](images/oysters.png){width=979}\n:::\n:::\n\nsource: https://fieldnotesjournal.org/new-blog/apearlintheroughoysteraquacultureandhowitworks\n\n\n## Overview\n\nMarine aquaculture has the potential to play an important role in the global food supply as a more sustainable protein option than land-based meat production.[^hall] [Gentry et al.](https://www.nature.com/articles/s41559-017-0257-9) \n\nFor this small project, we will determine which Exclusive Economic Zones (EEZ) on the West Coast of the US are best suited to developing marine aquaculture for several species of oysters.\n\nBased on previous research, we know that oysters needs the following conditions for optimal growth:\n\n-   sea surface temperature: 11-30 deg C\n-   depth: 0-70 meters below sea level\n\n##### Utilized skills: \n-   combining vector raster data\n-   resampling raster data\n-   masking raster data\n-   map algebra\n\n### Data\n#### Sea Surface Temperature\nWe will use average annual sea surface temperature (SST) from the years 2008 to 2012 to characterize the average sea surface temperature within the region. The data we are working with was originally generated from [NOAA's 5km Daily Global Satellite Sea Surface Temperature Anomaly v3.1](https://coralreefwatch.noaa.gov/product/5km/index_5km_ssta.php).\n\n#### Bathymetry\nTo characterize the depth of the ocean we will use the [General Bathymetric Chart of the Oceans (GEBCO)](https://www.gebco.net/data_and_products/gridded_bathymetry_data/#area).[^gebco]\n\n#### Exclusive Economic Zones\nWe will be designating maritime boundaries using Exclusive Economic Zones off of the west coast of US from [Marineregions.org](https://www.marineregions.org/eez.php).\n\n#### Prepare data \nTo start, we need to load all necessary data and make sure it has the coordinate reference system. \n    \n\n\n\n\nRead in the shapefile for the West Coast EEZ (`wc_regions_clean.shp`)\n\n::: {.cell}\n\n```{.r .cell-code}\nwc_regions <- st_read(here(file_path, \"data/wc_regions_clean.shp\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nReading layer `wc_regions_clean' from data source \n  `/Users/jaredpetry/Documents/MEDS/quarto_website/jaredbpetry.github.io/Posts/marine_aquaculture_geospatial/data/wc_regions_clean.shp' \n  using driver `ESRI Shapefile'\nSimple feature collection with 5 features and 5 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -129.1635 ymin: 30.542 xmax: -117.097 ymax: 49.00031\nGeodetic CRS:  WGS 84\n```\n:::\n:::\n\n\nRead in sea surface temperature rasters and combine them into a raster stack\n\n::: {.cell}\n\n```{.r .cell-code}\n# use list.files() to read in our data \n#--- you start with a bunch of tif files that you want to stack\n#--- I created a list of just the ones starting with the letter \"a\" to get the sst rasters I wanted\nfile_list <- list.files(path = \"data/\", pattern = \"^[a]\", full.names = TRUE)\n#--- now read them in using rast... this will create a spatraster with multiple layers\n#--- (this isn't an actual raster stack so let's see if this works.. terra calls them the same thing)\nsst_spatrast <- rast(file_list)\n#--- at this point you get a crs that says epsg4326 AND epsg9122 so we'll have to change that\n```\n:::\n\n\nRead in bathymetry raster (`depth.tif`)\\\n\n::: {.cell}\n\n```{.r .cell-code}\ndepth <- rast(here(file_path, \"data/depth.tif\"))\n```\n:::\n\n\nCheck that data are in the same coordinate reference system and reproject any data not in the same projection\n\n::: {.cell messages='false'}\n\n```{.r .cell-code}\n#--- depth raster is in lon/lat wgs84 EPSG:4326\n#--- wc_regions polygons in wgs84\n#--- sst_spatraster says lon/lat wgs84\n#depth <- st_transform(depth, crs = crs(sst_spatrast))\n\nset.crs(sst_spatrast, \"EPSG:4326\")\nset.crs(depth, \"EPSG:4326\")\nst_transform(wc_regions, crs = crs(depth)) #--- great now they are same crs\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSimple feature collection with 5 features and 5 fields\nGeometry type: MULTIPOLYGON\nDimension:     XY\nBounding box:  xmin: -129.1635 ymin: 30.542 xmax: -117.097 ymax: 49.00031\nGeodetic CRS:  WGS 84\n                  rgn rgn_key      area_m2 rgn_id  area_km2\n1              Oregon      OR 179994061293      1 179994.06\n2 Northern California    CA-N 164378809215      2 164378.81\n3  Central California    CA-C 202738329147      3 202738.33\n4 Southern California    CA-S 206860777840      4 206860.78\n5          Washington      WA  66898309678      5  66898.31\n                        geometry\n1 MULTIPOLYGON (((-123.4318 4...\n2 MULTIPOLYGON (((-124.2102 4...\n3 MULTIPOLYGON (((-122.9928 3...\n4 MULTIPOLYGON (((-120.6505 3...\n5 MULTIPOLYGON (((-122.7675 4...\n```\n:::\n:::\n\n\n#### Process data \nNext, we need process the SST and depth data so that they can be combined. In this case the SST and depth data have slightly different resolutions, extents, and positions. We don't want to change the underlying depth data, so we will need to resample to match the SST data using the nearest neighbor approach. \n\nFind the mean SST from 2008-2012\n\n::: {.cell}\n\n```{.r .cell-code}\nmean_sst_spatrast <- terra::app(sst_spatrast, mean) \n```\n:::\n\n\nConvert SST data from Kelvin to Celsius\n\n::: {.cell}\n\n```{.r .cell-code}\nmean_sst_C <- mean_sst_spatrast - 273.15\n```\n:::\n\n\nCrop depth raster to match the extent of the SST raster\n\n::: {.cell}\n\n```{.r .cell-code}\ndepth_cropped <- extend(depth, mean_sst_C)\n```\n:::\n\n\nResample the NPP data to match the resolution of the SST data using the nearest neighbor approach\n\n::: {.cell}\n\n```{.r .cell-code}\ndepth_cropped_resampled <- resample(depth_cropped, mean_sst_C, \n                                    method = \"near\")\n```\n:::\n\n\nCheck that the depth and SST match in resolution, extent, and coordinate reference system... can the rasters be stacked?\n\n::: {.cell}\n\n```{.r .cell-code}\n#--- try to stack the depth raster and the SST raster:\ndepth_and_sst <- raster::stack(c(depth_cropped_resampled, mean_sst_C))\n#--- yes! they can be stacked\n```\n:::\n\n\n#### Find suitable locations \nIn order to find suitable locations for marine aquaculture, we'll need to find locations that are suitable in terms of both SST and depth.\n\nReclassify SST and depth data into locations that are suitable for oysters. We will do this by setting suitable values to `1` and unsuitable values to `NA`\n\n::: {.cell}\n\n```{.r .cell-code}\n#--- for oysters, we need 11 <= sst(C) <= 30\n#------ and 0 <= depth <= 70\n\n#--- set up reclassification matrices \n\ndepth_rcl <- matrix(c(-8000, -70, NA,\n                    -70, 0, 1,\n                    0, 5000, NA), \n                 ncol = 3, byrow = TRUE)\n\nsst_rcl <- matrix(c(-Inf, 11, NA, \n                    11, 30, 1, \n                    30, Inf, NA), \n                 ncol = 3, byrow = TRUE)\n\n#--- use these to classify your rasters\n\nsuitable_sst <- classify(mean_sst_C, rcl = sst_rcl)\n\nsuitable_depth <- classify(depth_cropped_resampled, rcl = depth_rcl)\n\n#--- Plot what you just made for each \n\nplot(suitable_depth, col = \"blue\") \n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-12-1.png){width=672}\n:::\n\n```{.r .cell-code}\nplot(suitable_sst, col = \"blue\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-12-2.png){width=672}\n:::\n:::\n\n\nFind locations that satisfy both SST and depth conditions\\\n    - create an overlay using the `lapp()` function multiplying cell values\n    - we will use `terra::lapp()`\n    \n\n::: {.cell}\n\n```{.r .cell-code}\n#--- we want to multiply cell values so that with any NA in either layer, result will also be NA, with two 1s, the result will also be a 1\n\nfun = function(x,y) {\n  return(x*y)\n}\n\noyster_habitat <- lapp(c(suitable_depth, suitable_sst), fun)\n#--- plot(oyster_habitat)\n```\n:::\n\n\n#### Determine the most suitable EEZ \nWe want to determine the total suitable area within each EEZ in order to rank zones by priority. To do so, we need to find the total area of suitable locations within each EEZ.\n\n-   select suitable cells within West Coast EEZs\n-   find area of grid cells\n-   find the total suitable area within each EEZ\n    -   hint: it might be helpful to rasterize the EEZ data\n-   find the percentage of each zone that is suitable\n    -   hint it might be helpful to join the suitable area by region onto the EEZ vector data\n    \n\n::: {.cell}\n\n```{.r .cell-code}\n#--- remember, our eez regions are the wc_regions we reprojected earlier\n\n# select suitable cells within West Coast EEZs\n#----first rasterize the wc_regions data to create rast_eez\nrast_regions <- terra::rasterize(wc_regions, oyster_habitat, field = \"rgn\")\n\n# compute the area covered by the raster cells of suitable habitat\n#--- terra::cellSize() will compute the area covered by each individual cell\narea_habitat <- cellSize(oyster_habitat, unit = \"km\", transform = TRUE)\n\n#--- create mask that will display the suitable habitat separated into the different eez regions\nmask <- mask(rast_regions, oyster_habitat)\n\n#--- terra::zonal() will compute summaries of values of a spatraster defined by the \"zones\" of a different spatraster.  We will use this to compute the suitable area \nhabitat_area <- terra::zonal(area_habitat, mask, sum)\n\n#--- use left_join() to create a dataframe that contains both the suitable area by region and the percentage of habitat area out of the total area for that region\nhabitat_by_region_df <- left_join(wc_regions, habitat_area, by = \"rgn\")  \nhabitat_by_region_df$area_percent = (habitat_by_region_df$area / habitat_by_region_df$area_km2)*100\n\n#--- show results in a table\nprint_df <- habitat_by_region_df |> \n  terra::as.data.frame() |> \n  dplyr::select(rgn, area, area_percent) |> \n  dplyr::rename(\"Oyster Habitat Area\" = area, \n                \"EEZ region\" = rgn, \n                \"Habitat Percent of Total Region Area\" = area_percent) \nprint_df\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n           EEZ region Oyster Habitat Area Habitat Percent of Total Region Area\n1              Oregon           1074.2720                            0.5968374\n2 Northern California            178.0268                            0.1083028\n3  Central California           4069.8766                            2.0074530\n4 Southern California           3757.2849                            1.8163351\n5          Washington           2378.3137                            3.5551178\n```\n:::\n:::\n\n    \n#### Visualize results \nNow that we have results, we need to present them!\n\nWe will create the following maps:\n\n-   total suitable area by region\n-   percent suitable area by region\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#--- map of total area \narea_map <- tm_shape(habitat_by_region_df) + \n  tm_polygons(col = \"area\",\n              palette = rev(hcl.colors(3, \"BluGrn\")),\n              title = \"Habitat Area (square km)\",\n              legend.reverse = TRUE) +\ntm_shape(oyster_habitat) +\n  tm_raster(title = \"Habitat\") +\ntm_layout(legend.outside = TRUE,\n          main.title.size = 1,\n          main.title = \"Suitable habitat area for oysters by EEZ region\")\n\narea_map\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-15-1.png){width=672}\n:::\n\n```{.r .cell-code}\n#--- map of percentage\npercent_map <- tm_shape(habitat_by_region_df) +\n  tm_polygons(col = \"area_percent\",\n              palette = rev(hcl.colors(3, \"BluGrn\")),\n              title = \"Percentage\") +\ntm_shape(oyster_habitat) +\n  tm_raster(title = \"Habitat\") +\ntm_layout(legend.outside = TRUE,\n          main.title.size = 1,\n          main.title = \"Suitable habitat for oysters: percentage of total EEZ region\",\n          frame = T)\npercent_map\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-15-2.png){width=672}\n:::\n:::\n\n\n#### Broaden your workflow! \nNow that we've worked through the suitable habitat areas for one group of species, let's update our workflow to work for other species. We will do this by creating a function that would allow you to reproduce your results for other species. It will be able to do the following:\n\n-   accept temperature and depth ranges and species name as inputs\n-   create maps of total suitable area and percent suitable area per EEZ with the species name in the title\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfind_suitable_habitat <- function(spp_name, temp_min, temp_max, depth_min, depth_max) {\n  depth_rcl <- matrix(c(-Inf, depth_min, NA, \n                               depth_min, depth_max, 1, \n                               depth_max, Inf, NA), \n                              ncol = 3, byrow = TRUE)\n  sst_rcl <- matrix(c(-Inf, temp_min, NA, \n                             temp_min, temp_max, 1, \n                             temp_max, Inf, NA), \n                           ncol = 3, byrow = TRUE)\n  suitable_sst <- classify(mean_sst_C, rcl = sst_rcl)\n  suitable_depth <- classify(depth_cropped_resampled, rcl = depth_rcl)\n  oyster_habitat <- lapp(c(suitable_depth, suitable_sst), fun)\n  rast_regions <- terra::rasterize(wc_regions, oyster_habitat, field = \"rgn\")\n  area_suitable <- cellSize(oyster_habitat, unit = \"km\", transform = TRUE)\n  mask <- mask(rast_regions, oyster_habitat)\n  area_per_zone <- terra::zonal(area_suitable, mask, sum)\n  df_habitat_rgn <- left_join(wc_regions, area_per_zone, by = \"rgn\") \n  df_habitat_rgn$area_percent <- (df_habitat_rgn$area / df_habitat_rgn$area_km2)*100\n  #--- map of total area \n  area_and_percent_map <- tmap_arrange(tm_shape(df_habitat_rgn) + \n    tm_polygons(col = \"area\",\n                palette = rev(hcl.colors(3, \"BluGrn\")),\n                title = \"Area(km sq.)\",\n                legend.reverse = TRUE) +\n    tm_shape(oyster_habitat) +\n      tm_raster(title = \"Habitat\") +\n    tm_layout(legend.outside = TRUE,\n              legend.title.size = 0.8,\n              legend.text.size = 0.5,\n              main.title.size = 0.8,\n              main.title = paste0(spp_name, \" habitat by EEZ region\")),\n    percent_map <- tm_shape(df_habitat_rgn) +\n      tm_polygons(col = \"area_percent\",\n                  palette = rev(hcl.colors(3, \"BluGrn\")),\n                  title = \"Percentage\") +\n    tm_shape(oyster_habitat) +\n      tm_raster(title = \"Habitat\") +\n    tm_layout(legend.outside = TRUE,\n              legend.title.size = 0.8,\n              legend.text.size = 0.5,\n              main.title.size = 0.8,\n              main.title = paste0(spp_name, \" habitat percentage of EEZ region\"),\n              frame = T))\n  area_and_percent_map\n}\n#--- test the function (arbitrary values) \nfind_suitable_habitat(spp_name = \"spp of interest\", 5, 15, -100, 0)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-16-1.png){width=672}\n:::\n:::\n\n\n\nAnyone who wants to reproduce this workflow can do so easily! Run your function for a species of your choice! You can find information on species depth and temperature requirements on [SeaLifeBase](https://www.sealifebase.ca/search.php). Remember, we are thinking about the potential for marine aquaculture, so these species should have some reasonable potential for commercial consumption. \n\nI chose the American Lobster because it is a highly sought after food that could return lots of profit if grown in the right place.  I used to work at a fish market and it was extremely hard to get lobster because it is so hard to get nowadays!  The temperature range is 11-19 degC and the depth range is sea level to 480 meters deep.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfind_suitable_habitat(spp_name = \"American lobster\", 11, 19, -480, 0)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-17-1.png){width=672}\n:::\n:::\n\n\n\n[^hall]:Hall, S. J., Delaporte, A., Phillips, M. J., Beveridge, M. & O’Keefe, M. Blue Frontiers: Managing the Environmental Costs of Aquaculture (The WorldFish Center, Penang, Malaysia, 2011). \n\n[^gentry]:Gentry, R. R., Froehlich, H. E., Grimm, D., Kareiva, P., Parke, M., Rust, M., Gaines, S. D., & Halpern, B. S. Mapping the global potential for marine aquaculture. *Nature Ecology & Evolution*, 1, 1317-1324 (2017).\n\n[^gebco]:GEBCO Compilation Group (2022) GEBCO_2022 Grid (doi:10.5285/e0f0bb80-ab44-2739-e053-6c86abc0289c).\n\n#### SB depth data... just for fun\nCan I do a SB analysis with the depth data?\nI was going to try this to see bathymetry data for surf spor intel... however the data wasn't high enough resolution.  Oh well it still looks cool at least\n\n::: {.cell}\n\n```{.r .cell-code}\nrast_to_crop <- depth\nlat_up <- 34.522\nlat_down <- 34.085\nlon_up <- -120.223\nlon_down <- -119.171\n#--- formatting for ext(): -180, 180, -90, 90 (xmin, xmax, ymin, ymax)\nextent_of_crop <- terra::ext(lon_up, lon_down, lat_down, lat_up)\nsb_depth <- crop(rast_to_crop, extent_of_crop)\n\n#--- also crop the basemap to the same thing\n#sb_basemap <- extend(wc_regions, sb_depth)\n\ntm_shape(sb_depth) + tm_raster()\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nVariable(s) \"NA\" contains positive and negative values, so midpoint is set to 0. Set midpoint = NA to show the full spectrum of the color palette.\n```\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-18-1.png){width=672}\n:::\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}